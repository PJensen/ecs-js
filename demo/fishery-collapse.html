<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ecs-js — Fishery Collapse Demo</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0d1117;
      --panel: #111827;
      --accent: #67e8f9;
      --warn: #fcd34d;
      --err: #f87171;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: #e5e7eb;
      padding: 1.25rem clamp(1rem, 2vw, 3rem);
      line-height: 1.5;
    }
    h1 { margin: 0 0 0.25rem; }
    p { margin: 0.25rem 0 0.5rem; max-width: 72ch; }
    .panel {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
      margin: 0 0 1rem;
    }
    .controls { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    label { font-size: 0.9rem; opacity: 0.85; }
    input[type="number"], input[type="text"] { width: 8rem; padding: 0.35rem 0.5rem; border-radius: 8px; border: 1px solid #243143; background: #0b1626; color: #e5e7eb; }
    button {
      border: 1px solid #243143;
      border-radius: 8px;
      padding: 0.5rem 0.9rem;
      background: #172033;
      color: #e5e7eb;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }
    button:hover { background: #1f2b42; }
    button:active { transform: translateY(1px); }
    .pill { display: inline-flex; align-items: center; gap: 0.4rem; padding: 0.35rem 0.65rem; border-radius: 999px; font-size: 0.85rem; background: #13203b; border: 1px solid #1f2937; }
    .pill em { color: var(--accent); font-style: normal; font-weight: 700; }
    table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; }
    th, td { padding: 0.4rem 0.45rem; text-align: right; font-variant-numeric: tabular-nums; }
    th { text-align: right; font-weight: 600; opacity: 0.8; }
    tr:nth-child(odd) { background: rgba(255,255,255,0.02); }
    .status { text-align: left; }
    .ok { color: #bef264; }
    .warn { color: var(--warn); }
    .err { color: var(--err); }
    .small { font-size: 0.9rem; opacity: 0.8; }
    .notes { white-space: pre-line; font-family: "SFMono-Regular", Consolas, monospace; background: #0b1626; padding: 0.75rem; border-radius: 10px; border: 1px solid #1f2937; }
  </style>
</head>
<body>
  <header class="panel">
    <h1>Fishery collapse (one-shot demo)</h1>
    <p>This deterministic scenario shows how <code>ecs-js</code> handles a complex feedback loop: a single fish stock grows logistically, a fleet harvests it, and a policy layer adapts fishing effort to prevent collapse.</p>
    <div class="controls" aria-label="Simulation controls">
      <label for="seed">Seed</label>
      <input id="seed" type="text" value="0xc0ffee" inputmode="numeric" />
      <label for="years">Years</label>
      <input id="years" type="number" value="25" min="1" max="120" />
      <button id="run">Run scenario</button>
      <span class="pill" id="headline">Waiting to run…</span>
    </div>
    <p class="small">Adjust the seed or horizon, then re-run to replay the same dynamics. The world uses explicit phases (<code>growth → harvest → policy → detect → log</code>) to keep causality readable.</p>
  </header>

  <section class="panel">
    <h2>Year-by-year trajectory</h2>
    <table aria-label="Fishery outcomes">
      <thead>
        <tr>
          <th class="status">Year</th>
          <th>Biomass (kt)</th>
          <th>Catch (kt)</th>
          <th>Effort</th>
          <th>State</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </section>

  <section class="panel">
    <h2>Scenario notes</h2>
    <canvas id="chart" width="720" height="260" aria-label="Biomass and catch over time"></canvas>
    <div class="notes" id="notes"></div>
  </section>

  <script type="module">
    import { World, defineComponent, defineTag } from '../core.js';
    import { composeScheduler } from '../systems.js';
    import { createRealtimeRafLoop } from '../adapters/raf-adapters.js';

    const Stock = defineComponent('Stock', { biomass: 120, carrying: 200, growth: 0.6, noise: 0.08 });
    const Harvest = defineComponent('Harvest', { effort: 0.4, catchability: 0.03, maxEffort: 1.2 });
    const CollapseGate = defineComponent('CollapseGate', { at: 0.25, detected: false, year: null });
    const Pulse = defineComponent('Pulse', { catch: 0 });
    const Year = defineComponent('Year', { value: 0 });
    const Collapsed = defineTag('Collapsed');

    const rowsEl = document.getElementById('rows');
    const headlineEl = document.getElementById('headline');
    const notesEl = document.getElementById('notes');
    const seedInput = document.getElementById('seed');
    const yearsInput = document.getElementById('years');
    const runBtn = document.getElementById('run');
    const chartEl = document.getElementById('chart');
    const chartCtx = chartEl.getContext('2d');

    const fmt = (n, digits = 2) => Number(n).toFixed(digits);

    const stateLabel = (ratio) => {
      if (ratio < 0.15) return ['Collapsed', 'err'];
      if (ratio < 0.35) return ['Precarious', 'warn'];
      return ['Healthy', 'ok'];
    };

    function buildWorld(seed) {
      const world = new World({ seed, store: 'map' });
      world.setScheduler(composeScheduler('growth', 'harvest', 'policy', 'detect', 'log'));

      const stock = world.create();
      world.add(stock, Stock, { biomass: 140, carrying: 220, growth: 0.58, noise: 0.06 });
      world.add(stock, Harvest, { effort: 0.42, catchability: 0.028, maxEffort: 1.1 });
      world.add(stock, CollapseGate, { at: 0.22 });
      world.add(stock, Pulse, { catch: 0 });
      world.add(stock, Year, { value: 0 });

      world.system((w, dt) => {
        for (const [_id, s] of w.query(Stock)) {
          const growth = s.growth * s.biomass * (1 - s.biomass / s.carrying) * dt;
          const jitter = (w.rand() - 0.5) * 2 * s.noise * s.biomass;
          s.biomass = Math.max(1, Math.min(s.carrying, s.biomass + growth + jitter));
        }
      }, 'growth');

      world.system((w, dt) => {
        for (const [_id, s, h, pulse] of w.query(Stock, Harvest, Pulse)) {
          const catchTarget = s.biomass * h.catchability * h.effort * dt;
          const taken = Math.min(s.biomass, catchTarget);
          s.biomass -= taken;
          pulse.catch = taken;
        }
      }, 'harvest');

      world.system((w) => {
        for (const [_id, s, h] of w.query(Stock, Harvest)) {
          const ratio = s.biomass / s.carrying;
          if (ratio < 0.35) {
            h.effort = Math.max(0.05, h.effort * 0.86);
          } else if (ratio > 0.65 && h.effort < h.maxEffort) {
            h.effort = Math.min(h.maxEffort, h.effort * 1.06);
          } else {
            h.effort = Math.max(0.05, h.effort * 0.995);
          }
        }
      }, 'policy');

      world.system((w) => {
        for (const [id, s, gate, year] of w.query(Stock, CollapseGate, Year)) {
          const ratio = s.biomass / s.carrying;
          if (ratio < gate.at && !gate.detected) {
            gate.detected = true;
            gate.year = year.value + 1;
            if (!w.has(id, Collapsed)) w.add(id, Collapsed);
          }
        }
      }, 'detect');

      return { world, stock };
    }

    function runScenario(seed, horizon) {
      const { world: simWorld, stock } = buildWorld(seed);
      const history = [];

      simWorld.system((w) => {
        const [s, h, pulse, year, gate] = [w.get(stock, Stock), w.get(stock, Harvest), w.get(stock, Pulse), w.get(stock, Year), w.get(stock, CollapseGate)];
        const ratio = s.biomass / s.carrying;
        const collapsed = w.has(stock, Collapsed);
        const [label, cls] = collapsed ? ['Collapsed', 'err'] : stateLabel(ratio);
        year.value += 1;
        history.push({
          year: year.value,
          biomass: s.biomass,
          catch: pulse.catch,
          effort: h.effort,
          label,
          cls,
          collapseYear: gate.year,
        });
      }, 'log');

      return new Promise((resolve) => {
        const loop = createRealtimeRafLoop({
          world: { step: () => simWorld.tick(1) },
          render: () => drawChart(history, horizon),
          afterFrame: () => {
            if (history.length >= horizon) {
              loop.stop();
              resolve(history);
            }
          },
        });

        loop.start({ reset: true });
      });
    }

    function render(history) {
      rowsEl.innerHTML = history.map((row) => `
        <tr>
          <td class="status">${row.year}</td>
          <td>${fmt(row.biomass / 1000, 3)}</td>
          <td>${fmt(row.catch / 1000, 3)}</td>
          <td>${fmt(row.effort, 3)}</td>
          <td class="${row.cls}">${row.label}</td>
        </tr>
      `).join('');

      const latest = history[history.length - 1];
      headlineEl.innerHTML = `Year <em>${latest.year}</em>: <span class="${latest.cls}">${latest.label}</span> (biomass ${fmt(latest.biomass / 1000, 2)} kt)`;
      const highs = history.reduce((acc, r) => ({
        maxBiomass: Math.max(acc.maxBiomass, r.biomass),
        maxCatch: Math.max(acc.maxCatch, r.catch),
        minBiomass: Math.min(acc.minBiomass, r.biomass),
      }), { maxBiomass: 0, maxCatch: 0, minBiomass: Infinity });

      const collapseYear = history.find((r) => r.label === 'Collapsed')?.collapseYear ?? '–';
      notesEl.textContent = [
        `Max biomass: ${fmt(highs.maxBiomass / 1000, 2)} kt`,
        `Max catch:   ${fmt(highs.maxCatch / 1000, 2)} kt`,
        `Min biomass: ${fmt(highs.minBiomass / 1000, 2)} kt`,
        `Collapse year: ${collapseYear}`,
        '',
        'Phases executed each tick:',
        '  1. growth  — logistic rebound with seeded noise',
        '  2. harvest — fleet removes biomass using catchability & effort',
        '  3. policy  — adaptive effort throttles back near collapse',
        '  4. detect  — tags collapse once biomass crosses a gate',
        '  5. log     — capture a transcript row for the table',
        '',
        'Sources:',
        '  - Hilborn & Walters (1992) “Quantitative Fisheries Stock Assessment” — logistic growth & harvest control rules (Ch. 2-4)',
        '  - FAO Fisheries Circular 1011 (2006) — collapse thresholds & rebuilding heuristics',
      ].join('\n');
    }

    function drawChart(history, horizon) {
      const padding = 36;
      const w = chartEl.width;
      const h = chartEl.height;
      chartCtx.clearRect(0, 0, w, h);
      chartCtx.fillStyle = '#0b1626';
      chartCtx.fillRect(0, 0, w, h);
      chartCtx.strokeStyle = '#1f2937';
      chartCtx.lineWidth = 1;
      for (let y = 0; y <= 4; y++) {
        const yPos = padding + ((h - padding * 1.5) / 4) * y;
        chartCtx.beginPath();
        chartCtx.moveTo(padding, yPos);
        chartCtx.lineTo(w - padding / 2, yPos);
        chartCtx.stroke();
      }

      if (!history.length) return;
      const maxBiomass = Math.max(...history.map((d) => d.biomass));
      const maxCatch = Math.max(...history.map((d) => d.catch));
      const xFor = (i) => padding + (i / Math.max(1, horizon - 1)) * (w - padding * 1.5);
      const yFor = (val, max) => h - padding - (val / Math.max(1, max)) * (h - padding * 1.75);

      chartCtx.beginPath();
      history.forEach((d, i) => {
        const x = xFor(i);
        const y = yFor(d.biomass, maxBiomass);
        if (i === 0) chartCtx.moveTo(x, y);
        else chartCtx.lineTo(x, y);
      });
      chartCtx.strokeStyle = '#67e8f9';
      chartCtx.lineWidth = 2.5;
      chartCtx.stroke();

      chartCtx.beginPath();
      history.forEach((d, i) => {
        const x = xFor(i);
        const y = yFor(d.catch, maxCatch || 1);
        if (i === 0) chartCtx.moveTo(x, y);
        else chartCtx.lineTo(x, y);
      });
      chartCtx.strokeStyle = '#fcd34d';
      chartCtx.lineWidth = 2;
      chartCtx.stroke();

      const latest = history[history.length - 1];
      const collapsed = history.find((d) => d.label === 'Collapsed');
      chartCtx.fillStyle = '#e5e7eb';
      chartCtx.font = '12px system-ui, sans-serif';
      chartCtx.fillText('Biomass', padding, 16);
      chartCtx.fillStyle = '#67e8f9';
      chartCtx.fillRect(padding + 60, 8, 12, 12);
      chartCtx.fillStyle = '#e5e7eb';
      chartCtx.fillText('Catch', padding + 80, 16);
      chartCtx.fillStyle = '#fcd34d';
      chartCtx.fillRect(padding + 125, 8, 12, 12);
      if (collapsed) {
        const cx = xFor((collapsed.collapseYear ?? collapsed.year) - 1);
        chartCtx.strokeStyle = '#f87171';
        chartCtx.setLineDash([6, 5]);
        chartCtx.beginPath();
        chartCtx.moveTo(cx, padding / 2);
        chartCtx.lineTo(cx, h - padding / 2);
        chartCtx.stroke();
        chartCtx.setLineDash([]);
      }

      chartCtx.fillStyle = '#9ca3af';
      chartCtx.fillText(`Latest biomass: ${fmt(latest.biomass / 1000, 2)} kt`, w - 240, 16);
    }

    function start() {
      const seed = parseInt(seedInput.value, 0) >>> 0;
      const years = Math.max(1, Math.min(Number(yearsInput.value) || 0, 200));
      seedInput.value = seed;
      yearsInput.value = years;
      rowsEl.innerHTML = '';
      headlineEl.textContent = 'Running…';
      runScenario(seed, years).then((history) => render(history));
    }

    runBtn.addEventListener('click', start);
    start();
  </script>
</body>
</html>

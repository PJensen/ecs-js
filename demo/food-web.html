<!doctype html>
<meta charset="utf-8" />
<title>ecs-js ‚Äî Ecosystem Food-Web Sandbox</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  html, body { margin:0; height:100%; background:#05070c radial-gradient(circle at 20% 20%, #16304a55 0%, transparent 45%); color:#d6ecff; font:14px/1.4 "Inter", system-ui, -apple-system, sans-serif; }
  #wrap { display:grid; grid-template-columns:360px 1fr; height:100vh; }
  #ui { padding:16px; border-right:1px solid #1f2632; overflow:auto; background:linear-gradient(180deg, rgba(24,32,44,.9), rgba(7,10,14,.95)), radial-gradient(circle at 80% 10%, #145d7255 0%, transparent 35%); box-shadow:0 0 40px #0af2; }
  h1 { margin:0 0 6px; font-size:18px; letter-spacing:-0.01em; text-shadow:0 0 12px #5cfb; }
  p.blurb { margin:0 0 12px; color:#9bb3c9; }
  .row { margin:12px 0; }
  .row label { display:flex; justify-content:space-between; align-items:center; font-size:12px; color:#9bb3c9; margin:4px 0; }
  input[type=range] { width:100%; }
  .btns { display:flex; gap:8px; margin-top:8px; }
  button { background:linear-gradient(145deg,#0c415d,#0d2342); color:#b9eaff; border:1px solid #2b7da1; padding:7px 12px; border-radius:12px; cursor:pointer; box-shadow:0 0 16px #0af4 inset,0 0 10px #0af3; }
  button.sec { background:#161f29; border-color:#2c3c4d; color:#9bb3c9; }
  .toggle-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; font-size:12px; color:#9bb3c9; }
  .toggle-grid label { display:flex; align-items:center; gap:6px; }
  #hud { display:grid; grid-template-columns:auto 1fr; gap:4px 10px; font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0d131b; padding:10px; border-radius:12px; border:1px solid #1f2632; color:#8fe3c6; }
  #log { height:120px; overflow:auto; background:#0a0f15; border:1px solid #1f2632; border-radius:10px; padding:8px; font:12px/1.5 ui-monospace, monospace; color:#9bb3c9; white-space:pre-wrap; }
  canvas { width:100%; height:100%; display:block; background:#03050b; }
</style>
<div id="wrap">
  <div id="ui">
    <h1>üåø Ecosystem Food-Web Sandbox üåå</h1>
    <p class="blurb">Plants, herbivores, and predators interact across a seasonal biome. Scripts orchestrate climate shocks; phases keep the causal order explicit.</p>
    <div class="btns row">
      <button id="play">‚ñ∂Ô∏è Play</button>
      <button id="step" class="sec">‚è≠Ô∏è Step</button>
      <button id="reset" class="sec">üîÑ Reset</button>
    </div>
    <div class="row">
      <label>Sim speed (dt) <span id="dtVal"></span></label>
      <input id="dt" type="range" min="0.02" max="0.30" step="0.01" value="0.12">
    </div>
    <div class="row"><b style="color:#9dd7ff">Biome</b></div>
    <div class="row">
      <label>Rainfall <span id="rainVal"></span></label>
      <input id="rain" type="range" min="0.1" max="1.4" step="0.05" value="0.8">
      <label>Sunlight <span id="sunVal"></span></label>
      <input id="sun" type="range" min="0.1" max="1.5" step="0.05" value="1.0">
      <label>Seasonal swing <span id="swingVal"></span></label>
      <input id="swing" type="range" min="0.0" max="1.0" step="0.05" value="0.4">
    </div>
    <div class="row"><b style="color:#9dd7ff">Populations</b></div>
    <div class="row">
      <label>Start herbivores <span id="herbVal"></span></label>
      <input id="herb" type="range" min="10" max="200" step="5" value="120">
      <label>Start predators <span id="predVal"></span></label>
      <input id="pred" type="range" min="2" max="90" step="2" value="28">
      <label>Energy drain (all) <span id="drainVal"></span></label>
      <input id="drain" type="range" min="0.1" max="2.5" step="0.05" value="0.9">
    </div>
    <div class="row"><b style="color:#9dd7ff">Display</b></div>
    <div class="row toggle-grid">
      <label><input id="showHeat" type="checkbox" checked> Plant glows</label>
      <label><input id="showTrails" type="checkbox" checked> Animal trails</label>
      <label><input id="showSignals" type="checkbox" checked> Signals (events)</label>
      <label><input id="showContours" type="checkbox" checked> Territories</label>
    </div>
    <div id="hud" class="row">
      <span>‚è±Ô∏è Time</span><b id="tOut">0.00</b>
      <span>üåø Plants</span><b id="plantOut">‚Äî</b>
      <span>ü¶å Herbivores</span><b id="herbOut">‚Äî</b>
      <span>ü¶ä Predators</span><b id="predOut">‚Äî</b>
      <span>üì° Events</span><b id="evtOut">‚Äî</b>
      <span>üõ∞Ô∏è Status</span><b id="statusOut">OK</b>
    </div>
    <div class="row">
      <div>Event log</div>
      <div id="log"></div>
    </div>
    <div class="row" style="font-size:11px; color:#7ea0b5;">Phases: climate ‚Üí grow ‚Üí sense ‚Üí act ‚Üí decay ‚Üí render ‚Üí scripts. Scripts inject seasonal shocks and territory beacons.</div>
  </div>
  <canvas id="cv"></canvas>
</div>
<script type="module">
import {
  World,
  defineComponent,
  defineTag,
  defineArchetype,
  createFrom,
  PHASE_SCRIPTS,
  createRealtimeRafLoop,
} from '../index.js';

const DEFAULT_SEED = 0xFEEDBEEF >>> 0;

// ---------- Components ----------
const Biome = defineComponent('Biome', { cols: 64, rows: 42, rainfall: 0.8, sunlight: 1.0, swing: 0.4 });
const Field = defineComponent('Field', { plants: null, carrion: null, scent: null });
const Season = defineComponent('Season', { t: 0, temp: 0, rainPulse: 1, drought: 0, flare: 0, cols: 64, rows: 42 });
const Position = defineComponent('Position', { x: 0, y: 0 });
const Velocity = defineComponent('Velocity', { dx: 0, dy: 0 });
const Herbivore = defineComponent('Herbivore', { energy: 32, gestate: 0, lastMeal: 0 });
const Predator = defineComponent('Predator', { energy: 46, hunger: 0, target: -1 });
const Trail = defineComponent('Trail', { ttl: 12, hue: 180 });
const Signal = defineComponent('Signal', { ttl: 3, label: 'shock', strength: 1 });
const Metrics = defineComponent('Metrics', { plants: 0, herb: 0, pred: 0, events: 0 });
const SpawnBeacon = defineComponent('SpawnBeacon', { ttl: 2, hue: 60 });
const Beacon = defineTag('Beacon');

const EMOJI = {
  herb: ['ü¶å','üêá','ü¶ò'],
  pred: ['ü¶ä','üê∫','üêÜ'],
  plant: 'üåø',
  carrion: 'ü¶¥',
  drought: 'üåµ',
  flare: '‚ú®',
  rain: 'üåßÔ∏è',
  sun: '‚òÄÔ∏è',
  beacon: 'üì°',
  spark: ['‚ú®','üí´','‚ùáÔ∏è','üåü'],
};

const SKY_EMOJI = Array.from({ length: 36 }, () => ({
  x: Math.random(),
  y: Math.random(),
  glyph: EMOJI.spark[(Math.random() * EMOJI.spark.length) | 0],
  drift: 0.004 + Math.random() * 0.006,
}));

const COLORS = {
  skyTop: '#081228',
  skyBottom: '#050912',
  herb: '#74ffcf',
  pred: '#ff8c7a',
  plant: '#6ad96b',
  carrion: '#d9b36a',
};

// ---------- UI helpers ----------
const UI = {
  play: document.getElementById('play'),
  step: document.getElementById('step'),
  reset: document.getElementById('reset'),
  dt: document.getElementById('dt'),
  rain: document.getElementById('rain'),
  sun: document.getElementById('sun'),
  swing: document.getElementById('swing'),
  herb: document.getElementById('herb'),
  pred: document.getElementById('pred'),
  drain: document.getElementById('drain'),
  showHeat: document.getElementById('showHeat'),
  showTrails: document.getElementById('showTrails'),
  showSignals: document.getElementById('showSignals'),
  showContours: document.getElementById('showContours'),
  labels: {
    dt: document.getElementById('dtVal'), rain: document.getElementById('rainVal'), sun: document.getElementById('sunVal'), swing: document.getElementById('swingVal'),
    herb: document.getElementById('herbVal'), pred: document.getElementById('predVal'), drain: document.getElementById('drainVal'),
  },
  out: {
    t: document.getElementById('tOut'), plants: document.getElementById('plantOut'), herb: document.getElementById('herbOut'),
    pred: document.getElementById('predOut'), evt: document.getElementById('evtOut'), status: document.getElementById('statusOut'),
  },
  log: document.getElementById('log'),
};

function syncLabels(){
  UI.labels.dt.textContent = +UI.dt.value;
  UI.labels.rain.textContent = (+UI.rain.value).toFixed(2);
  UI.labels.sun.textContent = (+UI.sun.value).toFixed(2);
  UI.labels.swing.textContent = (+UI.swing.value).toFixed(2);
  UI.labels.herb.textContent = +UI.herb.value;
  UI.labels.pred.textContent = +UI.pred.value;
  UI.labels.drain.textContent = (+UI.drain.value).toFixed(2);
}
[UI.dt,UI.rain,UI.sun,UI.swing,UI.herb,UI.pred,UI.drain].forEach(el=>el.addEventListener('input', syncLabels));
syncLabels();

const CV = (()=>{ const cv = document.getElementById('cv'); const ctx = cv.getContext('2d'); function fit(){ const dpr = window.devicePixelRatio||1; cv.width=cv.clientWidth*dpr; cv.height=cv.clientHeight*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); } window.addEventListener('resize', fit); fit(); return { cv, ctx }; })();

const idx = (x,y,cols,rows)=>(( (y+rows)%rows)*cols + ((x+cols)%cols));
const pick = (arr, rand=Math.random)=>arr[(rand()*arr.length)|0];

function log(msg){ const time = new Date().toLocaleTimeString(); UI.log.textContent = `[${time}] ${msg}\n` + UI.log.textContent.slice(0, 2400); }

function worldMeta(){
  return world?.query(Biome, Field, Season, Metrics)[Symbol.iterator]().next().value || [];
}

function updateMetrics(partial){
  const meta = worldMeta();
  if(!meta.length) return;
  const [mid, , , , metrics] = meta;
  world.set(mid, Metrics, { ...metrics, ...partial });
}

function adjustPopCounts(dHerb = 0, dPred = 0){
  const meta = worldMeta();
  if(!meta.length) return;
  const [mid, , , , metrics] = meta;
  world.set(mid, Metrics, {
    ...metrics,
    herb: Math.max(0, (metrics.herb || 0) + dHerb),
    pred: Math.max(0, (metrics.pred || 0) + dPred),
  });
}

// ---------- World construction ----------
let world = null; let loop = null;

const Critter = defineArchetype('Critter', [Position, (p)=>({ x:p.x, y:p.y })], [Velocity, { dx:0, dy:0 }]);
const Grazer = defineArchetype('Grazer', Critter, [Trail, { ttl: 8, hue: 110 }]);
const Hunter = defineArchetype('Hunter', Critter, [Trail, { ttl: 8, hue: 10 }]);

function seedField(cols, rows, rainfall, sunlight, rand){
  const n = cols*rows; const plants = new Float32Array(n); const carrion = new Float32Array(n); const scent = new Float32Array(n);
  for(let i=0;i<n;i++) plants[i] = (0.8 + 0.4*rand()) * 14 * rainfall * sunlight;
  return { plants, carrion, scent };
}

function buildWorld(){
  world = World.create({ seed: DEFAULT_SEED, store: 'map', debug: true })
    .withPhases('climate','grow','sense','act','decay','render', PHASE_SCRIPTS)
    .useScripts({ phase: PHASE_SCRIPTS })
    .system(climateSystem, 'climate')
    .system(growSystem, 'grow')
    .system(senseSystem, 'sense')
    .system(actSystem, 'act')
    .system(decaySystem, 'decay')
    .system(balanceSystem, 'decay')
    .system(renderSystem, 'render')
    .build();

  world.on('shock', payload => { log(payload.msg); bumpEvents(1); });
  world.on('spawn', payload => { log(payload.msg); bumpEvents(0.2); });

  world.script('seasonal-shocks', (s) => {
    s.onTick((_world, _id, dt) => {
      for (const [id, season] of world.query(Season)) {
        if (season.drought <= 0 && world.rand() < 0.0015 * dt) {
          season.drought = 8 + world.rand()*12; world.emit('shock', { msg: `${EMOJI.drought} Dry spell triggered` });
          const sid = world.create();
          world.add(sid, Signal, { ttl:6, label:'drought', strength:1.2 });
          world.add(sid, Beacon);
          world.add(sid, Position, { x:(world.rand()*season.cols)|0, y:(world.rand()*season.rows)|0 });
        }
        if (season.flare <= 0 && world.rand() < 0.0012 * dt) {
          season.flare = 5 + world.rand()*8; world.emit('shock', { msg: `${EMOJI.flare} Solar flare ‚Äî predators sluggish` });
          const sid = world.create();
          world.add(sid, Signal, { ttl:4, label:'flare', strength:1.4 });
          world.add(sid, Position, { x:(world.rand()*season.cols)|0, y:(world.rand()*season.rows)|0 });
        }
      }
    });
  });

  const biome = world.create();
  const cols = 64, rows = 42;
  world.add(biome, Biome, { cols, rows, rainfall: +UI.rain.value, sunlight: +UI.sun.value, swing: +UI.swing.value });
  const { plants, carrion, scent } = seedField(cols, rows, +UI.rain.value, +UI.sun.value, world.rand);
  world.add(biome, Field, { plants, carrion, scent });
  world.add(biome, Season, { t: 0, temp: 0, rainPulse: 1, drought: 0, flare: 0, cols, rows });
  world.add(biome, Metrics, { plants:0, herb:0, pred:0, events:0 });
  world.addScript(biome, 'seasonal-shocks');

  for(let i=0;i<+UI.herb.value;i++) spawnHerb();
  for(let i=0;i<+UI.pred.value;i++) spawnPred();
}

function bumpEvents(x){ for (const [id, m] of world.query(Metrics)) world.set(id, Metrics, { ...m, events: m.events + x }); }

function spawnHerb(){
  const [meta, biome, field] = world.query(Biome, Field)[Symbol.iterator]().next().value || [];
  if (!biome) return;
  const pos = { x: world.rand()*biome.cols, y: world.rand()*biome.rows };
  const id = world.create();
  world.add(id, Position, pos);
  world.add(id, Velocity, { dx:0, dy:0 });
  world.add(id, Herbivore, { energy:32, gestate:0, lastMeal:0 });
  world.add(id, Trail, { ttl: 8, hue: 120 + 40*world.rand() });
  world.emit('spawn', { msg:`${pick(EMOJI.herb, world.rand)} Herbivore deployed` });
  adjustPopCounts(1, 0);
  const beacon = world.create();
  world.add(beacon, SpawnBeacon, { ttl: 1.5, hue: 110 });
  world.add(beacon, Position, pos);
  return id;
}
function spawnPred(){
  const [meta, biome] = world.query(Biome)[Symbol.iterator]().next().value || [];
  if (!biome) return;
  const pos = { x: world.rand()*biome.cols, y: world.rand()*biome.rows };
  const id = world.create();
  world.add(id, Position, pos);
  world.add(id, Velocity, { dx:0, dy:0 });
  world.add(id, Predator, { energy:46, hunger:0, target:-1 });
  world.add(id, Trail, { ttl: 8, hue: 12 });
  world.emit('spawn', { msg:`${pick(EMOJI.pred, world.rand)} Predator deployed` });
  adjustPopCounts(0, 1);
  const beacon = world.create();
  world.add(beacon, SpawnBeacon, { ttl: 1.5, hue: 20 });
  world.add(beacon, Position, pos);
  return id;
}

// ---------- Systems ----------
function climateSystem(world, dt){
  for(const [id, biome, field, season] of world.query(Biome, Field, Season)){
    season.t += dt;
    const seasonal = 0.5 + 0.5 * Math.sin(season.t * 0.15);
    season.temp = biome.sunlight * (1 + biome.swing * (seasonal - 0.5));
    season.rainPulse = biome.rainfall * (1 + biome.swing * (0.5 - seasonal));
    if (season.drought > 0) season.rainPulse *= 0.35, season.drought -= dt;
    if (season.flare > 0) season.temp *= 0.4, season.flare -= dt;
  }
}

function growSystem(world, dt){
  for(const [id, biome, field, season, metrics] of world.query(Biome, Field, Season, Metrics)){
    const { cols, rows } = biome; const N = cols*rows; const drain = +UI.drain.value;
    let totalPlants = 0;
    for(let i=0;i<N;i++){
      const grow = (0.25 + 0.8*season.rainPulse) * (0.5 + 0.5*season.temp);
      const loss = 0.01 * field.carrion[i];
      field.plants[i] = Math.max(0, field.plants[i] + dt * (grow - drain*0.02) - loss);
      field.carrion[i] = Math.max(0, field.carrion[i] - dt * 0.5);
      field.scent[i] = Math.max(0, field.scent[i] - dt * 0.6);
      totalPlants += field.plants[i];
    }
    world.set(id, Metrics, { ...metrics, plants: totalPlants });
  }
}

const HERB_SPEED = 5.4;
const PRED_SPEED = 6.5;

function sampleFieldAt(field, biome, x, y){
  const { cols, rows } = biome;
  const gx = ((Math.floor(x)%cols)+cols)%cols;
  const gy = ((Math.floor(y)%rows)+rows)%rows;
  const i = idx(gx, gy, cols, rows);
  return { plant: field.plants[i], carr: field.carrion[i], scent: field.scent[i], i };
}

function wrapPos(pos, biome){
  pos.x = (pos.x + biome.cols) % biome.cols;
  pos.y = (pos.y + biome.rows) % biome.rows;
}

function senseSystem(world, dt){
  const [bid, biome, field] = world.query(Biome, Field)[Symbol.iterator]().next().value || [];
  if(!biome) return;
  const predators = [...world.query(Position, Predator)].map(([,p])=>p);
  const herbs = [...world.query(Position, Herbivore)].map(([,p])=>p);

  for(const [id, herb] of world.query(Herbivore)){
    const pos = world.get(id, Position);
    let bestScore = -1e9; let dir = [Math.cos(world.rand()*Math.PI*2), Math.sin(world.rand()*Math.PI*2)];
    for(let k=0;k<10;k++){
      const ang = (k/10)*Math.PI*2 + world.rand()*0.2;
      const rx = pos.x + Math.cos(ang)*4.5;
      const ry = pos.y + Math.sin(ang)*4.5;
      const s = sampleFieldAt(field, biome, rx, ry);
      let fear = 0;
      for(const p of predators){ const dx=p.x-pos.x, dy=p.y-pos.y; const d2=dx*dx+dy*dy; if(d2<36) fear += (36-d2)*0.12; }
      const score = s.plant*0.8 - s.carr*0.35 + s.scent*0.12 - fear + world.rand()*0.6;
      if(score > bestScore){ bestScore = score; dir = [Math.cos(ang), Math.sin(ang)]; }
    }
    const jitter = (world.rand()-0.5)*0.6;
    const vx = dir[0] + jitter;
    const vy = dir[1] + (world.rand()-0.5)*0.6;
    const mag = Math.max(0.01, Math.hypot(vx, vy));
    world.set(id, Velocity, { dx: (vx/mag)*HERB_SPEED, dy: (vy/mag)*HERB_SPEED });
  }

  for(const [id, pred] of world.query(Predator)){
    const pos = world.get(id, Position);
    let closest = null, d2min = 1e9;
    for(const hp of herbs){
      const dx = hp.x - pos.x, dy = hp.y - pos.y; const d2 = dx*dx + dy*dy;
      if(d2 < d2min){ d2min = d2; closest = hp; }
    }
    let dir;
    if(closest){
      dir = [closest.x - pos.x, closest.y - pos.y];
    } else {
      let best=[Math.cos(world.rand()*Math.PI*2), Math.sin(world.rand()*Math.PI*2)]; let bestScore=-1e9;
      for(let k=0;k<8;k++){
        const ang = (k/8)*Math.PI*2 + world.rand()*0.3; const rx=pos.x+Math.cos(ang)*5; const ry=pos.y+Math.sin(ang)*5;
        const s = sampleFieldAt(field, biome, rx, ry);
        const score = s.scent*0.8 + s.carr*0.5 + world.rand()*0.3;
        if(score>bestScore){ bestScore=score; best=[Math.cos(ang), Math.sin(ang)]; }
      }
      dir = best;
    }
    const mag = Math.max(0.01, Math.hypot(dir[0], dir[1]));
    world.set(id, Velocity, { dx: (dir[0]/mag)*PRED_SPEED, dy: (dir[1]/mag)*PRED_SPEED });
  }
}

function actSystem(world, dt){
  const [bid, biome] = world.query(Biome)[Symbol.iterator]().next().value || [];
  for(const [id, pos, vel] of world.query(Position, Velocity)){
    if(biome){
      pos.x += vel.dx * dt * 6;
      pos.y += vel.dy * dt * 6;
      wrapPos(pos, biome);
    }
  }
  for(const [id, pos, herb] of world.query(Position, Herbivore)){
    const [bid2, biome2, field] = world.query(Biome, Field)[Symbol.iterator]().next().value || [];
    if(!biome2) continue; const sample = sampleFieldAt(field, biome2, pos.x, pos.y);
    const bite = Math.min(sample.plant, 2.5);
    field.plants[sample.i]-=bite; field.scent[sample.i]+=0.5;
    world.set(id, Herbivore, { ...herb, energy: herb.energy + bite*0.7, lastMeal: 0, gestate: herb.gestate + dt*bite*0.3 });
    world.set(id, Trail, { ttl: 12, hue: 120 + 60*Math.random() });
    if(herb.energy > 64 && herb.gestate > 6){ world.set(id, Herbivore, { ...herb, energy: herb.energy*0.5, gestate:0, lastMeal:0 }); spawnHerb(); }
  }
  for(const [id, pos, pred] of world.query(Position, Predator)){
    const [bid3, biome3, field] = world.query(Biome, Field)[Symbol.iterator]().next().value || [];
    if(!biome3) continue; const sample = sampleFieldAt(field, biome3, pos.x, pos.y);
    let ate=false;
    for(const [hid, hpos] of world.query(Position, Herbivore)){
      if(Math.hypot(hpos.x-pos.x, hpos.y-pos.y) < 0.4){ world.destroy(hid); adjustPopCounts(-1,0); field.carrion[sample.i]+=2.5; ate=true; break; }
    }
    const gain = ate? 8 : 0;
    world.set(id, Predator, { ...pred, energy: pred.energy + gain, hunger: pred.hunger + dt*(ate? -2:1) });
    field.scent[sample.i]+=1.2;
    world.set(id, Trail, { ttl: 12, hue: 12 });
    if(pred.energy>90){ world.set(id, Predator, { ...pred, energy: pred.energy*0.6, hunger:0 }); spawnPred(); }
  }
  for(const [id, sig] of world.query(Signal)){
    world.mutate(id, Signal, s => { s.ttl -= dt; });
    if(sig.ttl <= 0) world.destroy(id);
  }
}

function decaySystem(world, dt){
  const drain = +UI.drain.value;
  for(const [id, herb, pos] of world.query(Herbivore, Position)){
    const e = herb.energy - dt * drain;
    const lm = herb.lastMeal + dt;
    if(e <= 0 || lm>40){
      const [bid, biome, field] = world.query(Biome, Field)[Symbol.iterator]().next().value || [];
      if(biome){ const i=idx(pos.x,pos.y,biome.cols,biome.rows); field.carrion[i]+=4; field.scent[i]+=2; }
      world.destroy(id);
      adjustPopCounts(-1, 0);
    } else {
      world.set(id, Herbivore, { ...herb, energy: e, lastMeal: lm });
    }
  }
  for(const [id, pred, pos] of world.query(Predator, Position)){
    const e = pred.energy - dt * (drain*1.2 + pred.hunger*0.1);
    if(e <= 0){
      const [bid, biome, field] = world.query(Biome, Field)[Symbol.iterator]().next().value || [];
      if(biome){ const i=idx(pos.x,pos.y,biome.cols,biome.rows); field.carrion[i]+=6; field.scent[i]+=3; }
      world.destroy(id);
      adjustPopCounts(0, -1);
    } else {
      world.set(id, Predator, { ...pred, energy: e, hunger: Math.max(0, pred.hunger - dt*0.5) });
    }
  }
  for(const [id, trail] of world.query(Trail)){
    world.mutate(id, Trail, t => { t.ttl -= dt; });
    if(trail.ttl <= 0) world.remove(id, Trail);
  }
  for(const [id, beacon] of world.query(SpawnBeacon)){
    world.mutate(id, SpawnBeacon, b => { b.ttl -= dt; });
    if(beacon.ttl <= 0) world.destroy(id);
  }
}

function balanceSystem(world, _dt){
  const herbCount = [...world.query(Herbivore)].length;
  const predCount = [...world.query(Predator)].length;
  const targetHerb = Math.max(10, Math.floor(+UI.herb.value * 0.4));
  const targetPred = Math.max(4, Math.floor(+UI.pred.value * 0.35));
  const [mid, metrics] = world.query(Metrics)[Symbol.iterator]().next().value || [];
  if(metrics){
    world.set(mid, Metrics, { ...metrics, herb: herbCount, pred: predCount });
  }

  if(world.time > 0.5 && herbCount < targetHerb){
    const missing = Math.min(targetHerb - herbCount, 12);
    for(let i=0;i<missing;i++) spawnHerb();
  }
  if(world.time > 0.5 && predCount < targetPred && herbCount > targetHerb*0.5){
    const missing = Math.min(targetPred - predCount, 6);
    for(let i=0;i<missing;i++) spawnPred();
  }
}

function renderSystem(world, _dt, statsView){
  const { ctx, cv } = CV; ctx.clearRect(0,0,cv.width,cv.height);
  const [bid, biome, field, season, metrics] = world.query(Biome, Field, Season, Metrics)[Symbol.iterator]().next().value || [];
  if(!biome) return; const cw = cv.width / biome.cols, ch = cv.height / biome.rows; const t = world.time;

  const sky = ctx.createLinearGradient(0,0,0,cv.height);
  sky.addColorStop(0, COLORS.skyTop); sky.addColorStop(1, COLORS.skyBottom);
  ctx.fillStyle = sky; ctx.fillRect(0,0,cv.width,cv.height);

  // Aurora ribbons
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  const aurora = ctx.createLinearGradient(0,0,cv.width,cv.height);
  aurora.addColorStop(0, 'rgba(80,180,255,0.12)');
  aurora.addColorStop(1, 'rgba(180,120,255,0.14)');
  ctx.fillStyle = aurora;
  ctx.beginPath(); ctx.moveTo(0,cv.height*0.25); ctx.quadraticCurveTo(cv.width*0.35, cv.height*0.15, cv.width, cv.height*0.28); ctx.lineTo(cv.width, cv.height*0.45); ctx.quadraticCurveTo(cv.width*0.4, cv.height*0.35, 0, cv.height*0.5); ctx.closePath(); ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.font = `${Math.max(cw,ch)*0.9}px "Apple Color Emoji","Noto Color Emoji"`;
  for(const puff of SKY_EMOJI){
    const px = (puff.x*cv.width + Math.sin(t*puff.drift*3)*24) % cv.width;
    const py = (puff.y*cv.height + Math.cos(t*puff.drift*2)*18) % cv.height;
    ctx.fillText(puff.glyph, px, py);
  }
  ctx.restore();

  // Biomass nebula: floating blobs for plants + carrion
  if(UI.showHeat.checked){
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(let y=0;y<biome.rows;y+=2){
      for(let x=0;x<biome.cols;x+=2){
        const i = idx(x,y,biome.cols,biome.rows);
        const plant = field.plants[i];
        if(plant>1){
          const px=(x+0.5)*cw, py=(y+0.5)*ch;
          const r = Math.min(cw,ch) * (0.5 + Math.sqrt(plant)*0.12);
          const g = ctx.createRadialGradient(px,py,0,px,py,r*1.4);
          g.addColorStop(0, `rgba(90,255,150,0.28)`);
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(px,py,r*1.2,0,Math.PI*2); ctx.fill();
        }
        const carr = field.carrion[i];
        if(carr>0.6){
          const px=(x+0.5)*cw, py=(y+0.5)*ch;
          const r = Math.min(cw,ch) * (0.35 + Math.sqrt(carr)*0.15);
          const g = ctx.createRadialGradient(px,py,0,px,py,r*1.6);
          g.addColorStop(0, 'rgba(255,190,130,0.35)'); g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
        }
      }
    }
    ctx.restore();
    // sprinkle visible sprites for biomass
    ctx.save();
    ctx.font = `${Math.min(cw,ch)*0.85}px "Apple Color Emoji","Noto Color Emoji"`;
    for(let y=0;y<biome.rows;y+=3){
      for(let x=0;x<biome.cols;x+=3){
        const i = idx(x,y,biome.cols,biome.rows);
        const plant = field.plants[i];
        const carr = field.carrion[i];
        if(plant>5 && world.rand()>0.45){ ctx.fillText(EMOJI.plant, x*cw, y*ch); }
        if(carr>2.5 && world.rand()>0.65){ ctx.fillText(EMOJI.carrion, x*cw, y*ch); }
      }
    }
    ctx.restore();
  }
  if(UI.showContours.checked){
    ctx.strokeStyle = 'rgba(90,140,255,0.16)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.ellipse(cv.width*0.5, cv.height*0.45, cv.width*0.44, cv.height*0.28, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(cv.width*0.4, cv.height*0.65, cv.width*0.36, cv.height*0.2, 0, 0, Math.PI*2); ctx.stroke();
  }
  // Signals and rally beacons
  for(const [id, pos, sig] of world.query(Position, Signal)){
    const r = (2+sig.ttl*4); const hue = sig.label==='drought'?28:300; const glyph = sig.label==='drought'?EMOJI.drought:EMOJI.flare;
    const grad = ctx.createRadialGradient((pos.x+0.5)*cw,(pos.y+0.5)*ch,2,(pos.x+0.5)*cw,(pos.y+0.5)*ch,r*4);
    grad.addColorStop(0, `hsla(${hue},90%,70%,0.5)`); grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.fillRect((pos.x-3)*cw, (pos.y-3)*ch, cw*7, ch*7);
    ctx.strokeStyle = `hsla(${hue},100%,70%,0.8)`; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc((pos.x+0.5)*cw,(pos.y+0.5)*ch,r,0,Math.PI*2); ctx.stroke();
    ctx.font = `${Math.min(cw,ch)*1.1}px "Apple Color Emoji","Noto Color Emoji"`; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText(glyph,(pos.x+0.08)*cw,(pos.y+0.9)*ch);
  }
  for(const [id, pos, beacon] of world.query(Position, SpawnBeacon)){
    const alpha = Math.max(0, beacon.ttl/2);
    ctx.strokeStyle = `hsla(${beacon.hue},95%,65%,${0.8*alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc((pos.x+0.5)*cw,(pos.y+0.5)*ch, cw*0.55, 0, Math.PI*2); ctx.stroke();
  }
  // Trails and command arrows
  if(UI.showTrails.checked){
    for(const [id, pos, trail] of world.query(Position, Trail)){
      const r = Math.min(cw,ch)*0.55;
      ctx.fillStyle = `hsla(${trail.hue},90%,70%,${Math.max(0, trail.ttl/12)})`;
      ctx.shadowColor = `hsla(${trail.hue},100%,70%,0.55)`; ctx.shadowBlur = 12;
      ctx.beginPath(); ctx.arc((pos.x+0.2)*cw, (pos.y+0.2)*ch, r, 0, Math.PI*2); ctx.fill();
    }
    ctx.shadowBlur = 0; ctx.shadowColor='transparent';
  }
  // Units (emoji + bounding circles)
  ctx.font = `${Math.min(cw,ch)*0.95}px "Apple Color Emoji","Noto Color Emoji"`;
  for(const [id, pos, herb] of world.query(Position, Herbivore)){
    const energy = Math.max(0, Math.min(1, herb.energy/64));
    const r = Math.min(cw,ch)*0.58;
    const px = pos.x*cw, py = pos.y*ch;
    ctx.save();
    ctx.shadowColor='rgba(120,255,180,0.5)'; ctx.shadowBlur=18;
    ctx.strokeStyle=`rgba(100,255,200,${0.5+0.4*energy})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(px, py, r*0.9, 0, Math.PI*2); ctx.stroke();
    ctx.strokeStyle=`rgba(0,0,0,0.7)`; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(px, py, r*0.7, -Math.PI/2, -Math.PI/2 + Math.PI*2*energy); ctx.stroke();
    ctx.fillStyle='rgba(0,0,0,0.32)'; ctx.beginPath(); ctx.arc(px, py, r*0.65, 0, Math.PI*2); ctx.fill();
    ctx.fillText(EMOJI.herb[id % EMOJI.herb.length], px - r*0.4, py + r*0.4);
    ctx.restore();
  }
  for(const [id, pos, pred] of world.query(Position, Predator)){
    const energy = Math.max(0, Math.min(1, pred.energy/90));
    const r = Math.min(cw,ch)*0.6;
    const px = pos.x*cw, py = pos.y*ch;
    ctx.save();
    ctx.shadowColor='rgba(255,120,120,0.65)'; ctx.shadowBlur=18;
    ctx.strokeStyle=`rgba(255,140,120,${0.55+0.35*energy})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.stroke();
    ctx.strokeStyle='rgba(0,0,0,0.8)'; ctx.lineWidth=7; ctx.beginPath(); ctx.arc(px, py, r*0.74, -Math.PI/2, -Math.PI/2 + Math.PI*2*energy); ctx.stroke();
    ctx.fillStyle='rgba(0,0,0,0.38)'; ctx.beginPath(); ctx.arc(px, py, r*0.7, 0, Math.PI*2); ctx.fill();
    ctx.fillText(EMOJI.pred[id % EMOJI.pred.length], px - r*0.42, py + r*0.25);
    ctx.restore();
  }

  UI.out.t.textContent = world.time.toFixed(2);
  UI.out.plants.textContent = metrics ? metrics.plants.toFixed(0) : '‚Äî';
  UI.out.herb.textContent = metrics ? metrics.herb : [...world.query(Herbivore)].length;
  UI.out.pred.textContent = metrics ? metrics.pred : [...world.query(Predator)].length;
  UI.out.evt.textContent = metrics ? metrics.events.toFixed(1) : '‚Äî';
  UI.out.status.textContent = season && season.drought>0 ? `${EMOJI.drought} Drought` : season && season.flare>0 ? `${EMOJI.flare} Aurora` : `${EMOJI.sun} Stable`;
}

// ---------- Loop ----------
let runner = null;

function setRunningUi(running){ UI.play.textContent = running ? '‚è∏ Pause üå†' : '‚ñ∂Ô∏è Play'; }

function reset(){
  loop?.stop();
  buildWorld();
  runner = { tick: () => world.tick(+UI.dt.value) };
  loop = createRealtimeRafLoop({ world: runner, stepFrame: (_dt, stats)=>renderSystem(world, _dt, stats) });
  UI.log.textContent='';
  loop.start({ reset:true });
  setRunningUi(true);
}

function step(){ if(!world || loop?.isRunning()) return; world.tick(+UI.dt.value); renderSystem(world,0); }

function togglePlay(){ if(!loop) return; if(loop.isRunning()){ loop.stop(); setRunningUi(false); } else { loop.start(); setRunningUi(true); } }

UI.play.addEventListener('click', togglePlay);
UI.step.addEventListener('click', step);
UI.reset.addEventListener('click', reset);

syncLabels(); reset();
</script>
